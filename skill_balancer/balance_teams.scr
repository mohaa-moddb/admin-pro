main:
	if(level.run[team_balance] != 1){end}

	exec skill_balancer\dovars.scr
	level waittill spawn
	wait 60
	level.pmp = int 1
	level.tbi = int 0
	level.tplayers = int 0
	level.useskill = waitexec global/settings.scr::getcmd "use_skill"
	level.scanwait =  waitexec global/settings.scr::getcmd "scan_wait"
	level.g_teamswitchdelay = waitexec global/settings.scr::getcmd "g_teamswitchdelay"
	level.gracetime = int level.scanwait * 2
	thread team_b
	thread time_add
	thread monitor_vars
end




team_b:

	while(level.run[team_balance] == 1)
	{
		//reset player ammount vars
		wait level.scanwait
		level.ap = int 0
		level.gp = int 0

		//scan players to determine team sizes
		if ($player.size > 2)
		{
			for (local.i = 1; local.i <= $player.size; local.i++ )
			{
				waitframe 
				if ($player[local.i].dmteam == "allies")
				{
					level.ap ++
				}

				if ($player[local.i].dmteam == "axis")
				{
					level.gp ++
				}
			}


			//sort out death proceed var value

			if ($player.size >= 37)
			{
				local.deathproceed = int 4 * $player.size
			}
			else if ($player.size < 37)
			{
				local.deathproceed = int 5 * $player.size
			
				if ($player.size < 29)
				{
					local.deathproceed = int 6 * $player.size

					if ($player.size < 21)
					{
						local.deathproceed = int 7 * $player.size
		
						if ($player.size < 13)
						{
							local.deathproceed = int 8 * $player.size
		
							if ($player.size < 5)
							{
								local.deathproceed = int 9 * $player.size
							}
						}
					}
				}
			}

			//sort out sh var value
			if (level.adc > local.deathproceed || level.gdc > local.deathproceed )
			{
				local.sh = "1"
			}
			else
			{
				local.sh = "0"
			}


			//figure out the difference in players to help calculate the temp move factor and other things
			if (level.ap > level.gp)
			{
				level.pd = level.ap - level.gp
			}
			else
			{
				level.pd = level.gp - level.ap
			}



			if (local.sh == "1" && level.useskill == "1")					//teams must be at least 3 players big for effective balancing and a score at a high-ish level
			{
				// make sure script doesnt over-do the balancing!
				local.playerfraction = ((float (level.ap) + float (level.gp)) / 5.000) * 2.900

				//asign tempfactor var
				local.tempfactoru = float level.pd * 0.22
				local.tempfactord = float level.pd * 0.19
				//reset allied and axis move ammounts
				level.alliesmove = float 0.000
				level.axismove = float 0.000



				//balance the teams in allies favour
				if (level.adc > level.gdc)
				{
					//calculate differences in team deaths and balance teams
					if ( level.ap <= int (local.playerfraction - 1))
					{
						//calculate differnce in players to determine the movefactor
						if (level.ap > level.gp)
						{
							local.movefactor = float 1.5 + local.tempfactoru
						}
						else
						{
							local.movefactor = float 1.5 - local.tempfactord
						}

						local.gpe = float level.gp + level.tbi
						local.dthdiff = int level.adc - level.gdc
						level.dthrat = float (float (level.adc) / float (local.gpe)) * local.movefactor
						level.axismove = float local.dthdiff / level.dthrat
						level.alliesmove = float 0.000

						if ( level.axismove >= 2)
						{
							local.totalfutureplayers = float level.axismove + level.ap
							if (local.totalfutureplayers > local.playerfraction)
							{
									level.axismove = float 1.100 
							}
						}

						if ( level.axismove < 0.4 || local.dthdiff < 20)
						{
							//balance the teams based on size as skill limit may be unreliable
							thread norm_balance
						}
					}
					else
					{
						if ( level.ap > local.playerfraction)
						{
							level.alliesmove = float 1.100
						}
					}
				}

				//balance the teams in axis favour
				if (level.gdc > level.adc)
				{
					if ( level.gp <= int (local.playerfraction - 1))
					{
						//calculate differnce in players to determine the movefactor
						if (level.gp > level.ap)
						{
							local.movefactor = float 1.5 + local.tempfactoru
						}
						else
						{
							local.movefactor = float 1.5 - local.tempfactord
						}

						local.ape = float level.ap + level.tbi
						local.dthdiff = int level.gdc - level.adc
						level.dthrat = float (float (level.gdc) / float (local.ape)) * local.movefactor
						level.alliesmove = float local.dthdiff / level.dthrat
						level.axismove = float 0.000

						if ( level.alliesmove >= 2)
						{
							local.totalfutureplayers = float level.alliesmove + level.gp
							if (local.totalfutureplayers > local.playerfraction)
							{
								level.alliesmove = float 1.100
							}
						}

						if ( level.alliesmove < 0.4 || local.dthdiff < 20)
						{
							//balance the teams based on size as skill limit may be unreliable
							thread norm_balance
						}
					}
					else
					{
						if ( level.gp > local.playerfraction)
						{
							level.axismove = float 1.100
						}
					}
				}
				//reset level.pmp var
				level.pmp = int 1
			}
			else
			{
				thread norm_balance
			}
		}

	}

end




monitor_vars:

	while(level.run[team_balance] == 1)
	{
		if (level.alliesmove >= 1 || level.axismove >= 1 )
		{
			if (level.pmp > 12)
			{
				level.pmp = int 12
			}
			else if (level.pmp < 1)
			{
				level.pmp = int 1
			}

			switch (level.pmp)
			{
			case 1:
				local.finalvar = $player.size
				println ("level.pmp = " + level.pmp + " ")
			break
			case 2:
				local.finalvar = int ( $player.size - 1 )
				println ("level.pmp = " + level.pmp + " ")
			break
			case 3:
				local.finalvar = int ( $player.size - 2 )
				println ("level.pmp = " + level.pmp + " ")
			break
			case 4:
			local.randomplayer = randomint ( $player.size / 3 )
				local.finalvar = int $player.size - local.randomplayer
				println ("level.pmp = " + level.pmp + " ")
			break
			case 5:
				local.randomplayer = randomint ( $player.size / 3 )
				local.finalvar = int $player.size - local.randomplayer
				println ("level.pmp = " + level.pmp + " ")
			break
			case 6:
				local.randomplayer = randomint ( $player.size / 2 )
				local.finalvar = int $player.size - local.randomplayer
				println ("level.pmp = " + level.pmp + " ")
			break
			case 7:
				local.randomplayer = randomint ( $player.size / 2 )
				local.finalvar = int $player.size - local.randomplayer
				println ("level.pmp = " + level.pmp + " ")
			break
			case 8:
				local.randomplayer = randomint ( $player.size / 2 )
				local.finalvar = int $player.size - local.randomplayer
				println ("level.pmp = " + level.pmp + " ")
			break
			case 9:
				local.randomplayer = randomint ( $player.size / 1.5 )
				local.finalvar = int $player.size - local.randomplayer
				println ("level.pmp = " + level.pmp + " ")
			break
			case 10:
				local.randomplayer = randomint ( $player.size / 1.5 )
				local.finalvar = int $player.size - local.randomplayer
				println ("level.pmp = " + level.pmp + " ")
			break
			case 11:
				local.randomplayer = randomint ( $player.size / 1.5 )
				local.finalvar = int $player.size - local.randomplayer
				println ("level.pmp = " + level.pmp + " ")
			break
			case 12:
				local.randomplayer = randomint $player.size 
				println ("level.pmp = " + level.pmp + " ")

				if ( local.randomplayer == 0)
				{
					local.randomplayer = int 1
				}
				local.finalvar = local.randomplayer
			break
			}

			//randomly move the last few players to join the server
			$player[local.finalvar] thread move_player
		}

		wait 0.8
	}
end


move_player: 

	local.tempam = float level.alliesmove
	local.tempgm = float level.axismove
	local.rememberdelay = level.g_teamswitchdelay
	level.g_teamswitchdelay = "1"
	waitframe


	//gets values from team balance script and performs team balance if required
	//balance teams for axis
	if (self.dmteam == "allies" && level.alliesmove >= 1 && self.movedrecent == "0")
	{
		self stufftext "join_team axis" 
		wait 0.2
		level.g_teamswitchdelay = local.rememberdelay

		//check to make sure they did join the axis, then alter vars accordingly
		if (self.dmteam == "axis")
		{
			level.alliesmove -= 1
			self iprint "THE TEAMS ARE UNBALANCED" 1
			waitframe
			self iprint "You have been moved to the axis to help balance the teams"
			self iprint "Balancing is not just done on team size- but also on team score as well"
			self.movedrecent = "1"
			waitframe
			level.pmp = int 1
			end
		}
	}
	//balance teams for allies
	if (self.dmteam == "axis" && level.axismove >= 1 && self.movedrecent == "0") 
	{
		self stufftext "join_team allies" 

		wait 0.2
		 level.g_teamswitchdelay =  local.rememberdelay
		//check to make sure they did join the allies, then alter vars accordingly
		if (self.dmteam == "allies")
		{

		level.axismove -= 1

		self iprint "THE TEAMS ARE UNBALANCED" 1
		waitframe
		self iprint "You have been moved to the allies to help balance the teams"
		self iprint "Balancing is not just done on team size- but also on team score as well"
		self.movedrecent = "1"
		waitframe
		level.pmp = int 1
		end
		}
	}
	waitframe
	if (local.tempam == level.alliesmove && local.tempgm == level.axismove)
	{
		level.pmp ++
	}
	  level.g_teamswitchdelay = local.rememberdelay
	end


	norm_balance:
	println ("   ***norm_balance doing***    ")

	if (level.ap > int (level.gp + 1))
	{
		level.alliesmove = float level.pd / 2
	}

	if (level.gp > int (level.ap + 1))
	{
		level.axismove = float level.pd / 2
	}

	if (level.pd == 1)
	{
		if (level.ap < level.gp && int ( level.adc - 20 ) > level.gdc)
		{
			level.axismove = float 1.100
		}

		if (level.gp < level.ap && int ( level.gdc - 20 ) > level.adc)
		{
			level.alliesmove = float 1.100
		}

	}
end

time_add:

	while(level.run[team_balance] == 1)
	{	
		//increment a value to help gain accurate balancing occur
		wait 60
		if ($player.size > 2)
		{
			level.addtb = float $player.size / 150.00
			thread inc_tbi
		}
	}
end


inc_tbi:
	waitframe
	level.tbi += level.addtb
end


